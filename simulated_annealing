import math
import random
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Callable
import optimization_functions as optF

Solution = List[float]
OptFunction = Callable[[Solution], float]

def generateSolution(length : int, a : float, b: float) -> Solution:
    return [np.random.uniform(a, b) for _ in range(length)]

def simplePerturbation(solution: Solution, a : float, b: float) -> Solution:
    i = random.randrange(len(solution))
    solution[i] += np.random.uniform(-0.5, 0.5)
    if solution[i] > b:
        solution[i] = b
    if solution[i] < a:
        solution[i] = a
    return solution

def simulated_annealing(
        objectiveFunc : OptFunction, 
        solutionLen : int,
        a : float,
        b : float, 
        temperature : float, 
        coolingRate : float, 
        stopingTemp : float,
        restartTreshold : float) \
            -> Solution:
    
    iterations = np.array([])
    temperatures = np.array([])
    bestSolutions = np.array([])

    initialTemp = temperature
    initialSol = generateSolution(solutionLen, a, b)

    curSol = initialSol
    bestSol = initialSol
    
    k = 0
    while temperature > stopingTemp:
        k += 1
        iterations = np.append(iterations, k)
        temperatures = np.append(temperatures, temperature)

        newSol = simplePerturbation(curSol.copy(), a, b)
        curCost = objectiveFunc(curSol)
        newCost = objectiveFunc(newSol)
        
        delta = newCost - curCost
        if newCost < curCost:
            curSol = newSol
            if newCost < objectiveFunc(bestSol):
                bestSol = newSol
        else:
            if random.random() < math.exp(-delta / temperature):
                curSol = newSol
            if random.random() < math.exp(-delta / temperature) and temperature < initialTemp:
                temperature *= 1/coolingRate

        temperature *= coolingRate

        # Cuando se ha llegado a la mitad de la temperatura inticial y si el mejor resultado
        # no supera al valor de treshold establecido, la temperatura se reinicia 
        if temperature < initialTemp/2 and objectiveFunc(bestSol) > restartTreshold:
            temperature = initialTemp

        """ if temperature < initialTemp/4 and objectiveFunc(bestSol) > restartTreshold/2:
            temperature = initialTemp/2 """

        bestSolutions = np.append(bestSolutions, objectiveFunc(bestSol))

    print("\nSimulated Annealing\n")
    print("Initial Parameters")
    print("\tInitial Temperature:", initialTemp)
    print("\tStopping Temperature:", stopingTemp)
    print("\tCooling Rate (Exponential):", coolingRate)
    print("\tRestart treshold value:", restartTreshold)

    print("\nResults")
    print("\tTotal iterations:", k)
    print("\tInitial Solution:", initialSol)
    print("\tObjective Function value:", objectiveFunc(initialSol))
    print("\n\tBest Solution:", bestSol)
    print("\tObjective Function value:", objectiveFunc(bestSol))

    # Grafica de temperaturas
    plt.figure()
    plt.plot(iterations,temperatures)
    plt.title("Simulated Annealing")
    plt.xlabel("Número de Iteración")
    plt.ylabel("Temperatura")
    plt.show()

    # Grafica de Mejor Soluciones por iteracion
    plt.figure()
    plt.plot(iterations,bestSolutions)
    plt.title("Simulated Annealing")
    plt.xlabel("Número de Iteración")
    plt.ylabel("E(S)")
    plt.show()

    return bestSol

temperature = 200
coolingRate = 0.95
stopingTemp = 1e-12
restartTreshold = 60

simulated_annealing(optF.rastrigin, 5, -5.12, 5.12, temperature, coolingRate, stopingTemp, restartTreshold)
simulated_annealing(optF.threeHumpCamel, 2, -5, 5, temperature, coolingRate, stopingTemp, restartTreshold)